export const flowKinds = [
	"expression_statement",
	"if_statement",
	"for_statement",
	"while_statement",
] as const;
export type FlowKind = (typeof flowKinds)[number];

export const importKinds = [
	// different types of imports
	"import_statement",
	"import_from_statement",
	"future_import_statement",
] as const;
export type ImportKind = (typeof importKinds)[number];

export const definitionKinds = [
	"function_definition",
	"decorated_definition",
	"class_definition",
] as const;

export type DefinitionKind = (typeof definitionKinds)[number];

export const kinds = [
	"comment",
	...importKinds,
	...definitionKinds,
	...flowKinds,
] as const;
export type Kind = (typeof kinds)[number];

export const astSchema = {
	module: [
		"import_statement",
		"import_from_statement",
		"comment",
		"function_definition",
		"decorated_definition",
		"class_definition",
		"expression_statement",
		"if_statement",
	],
	import_statement: ["import", "dotted_name"],
	import_from_statement: ["from", "dotted_name", "import", ","],
	function_definition: ["def", "identifier", "parameters", ":", "block"],
	decorated_definition: ["decorator", "function_definition"],
	class_definition: ["class", "identifier", "argument_list", ":", "block"],
	expression_statement: ["assignment", "call", "augmented_assignment", "yield"],
	if_statement: [
		"if",
		"comparison_operator",
		":",
		"block",
		"else_clause",
		"attribute",
		"elif_clause",
		"identifier",
	],
	dotted_name: ["identifier"],
	parameters: [
		"(",
		"identifier",
		")",
		",",
		"default_parameter",
		"list_splat_pattern",
		"dictionary_splat_pattern",
	],
	block: [
		"decorated_definition",
		"return_statement",
		"pass_statement",
		"function_definition",
		"while_statement",
		"expression_statement",
		"try_statement",
		"for_statement",
		"if_statement",
		"with_statement",
		"continue_statement",
		"comment",
		"break_statement",
		"raise_statement",
	],
	decorator: ["@", "identifier", "call"],
	argument_list: [
		"(",
		"identifier",
		")",
		",",
		"string",
		"call",
		"binary_operator",
		"integer",
		"list_splat",
		"dictionary_splat",
		"attribute",
		"keyword_argument",
		"list_comprehension",
		"subscript",
		"generator_expression",
		"none",
	],
	assignment: [
		"identifier",
		"=",
		"lambda",
		"call",
		"attribute",
		"list",
		"integer",
		"none",
		"string",
		"dictionary",
		"parenthesized_expression",
		"conditional_expression",
		"subscript",
		"true",
		"false",
		"list_comprehension",
	],
	comparison_operator: [
		"identifier",
		"==",
		"string",
		"attribute",
		"<=",
		"integer",
		"in",
		">",
		"call",
	],
	return_statement: ["return", "identifier", "string", "attribute", "call"],
	pass_statement: ["pass"],
	while_statement: [
		"while",
		"true",
		":",
		"block",
		"attribute",
		"boolean_operator",
	],
	lambda: ["lambda", "lambda_parameters", ":", "call"],
	string: ["string_start", "string_content", "string_end", "interpolation"],
	try_statement: ["try", ":", "block", "finally_clause", "except_clause"],
	lambda_parameters: ["identifier"],
	call: ["identifier", "argument_list", "attribute"],
	attribute: ["identifier", ".", "call", "attribute", "string"],
	string_content: ["escape_sequence"],
	finally_clause: ["finally", ":", "block"],
	for_statement: ["for", "identifier", "in", "attribute", ":", "block"],
	default_parameter: ["identifier", "=", "string"],
	with_statement: ["with", "with_clause", ":", "block"],
	list_splat_pattern: ["*", "identifier"],
	dictionary_splat_pattern: ["**", "identifier"],
	augmented_assignment: ["attribute", "-=", "identifier"],
	yield: ["yield", "call", "identifier"],
	binary_operator: ["attribute", "+", "integer"],
	except_clause: ["except", "as_pattern", ":", "block", "identifier"],
	boolean_operator: ["comparison_operator", "and"],
	with_clause: ["with_item"],
	list: ["[", "]"],
	interpolation: ["{", "attribute", "}", "identifier"],
	else_clause: ["else", ":", "block"],
	dictionary: ["{", "}", "pair", ","],
	parenthesized_expression: ["(", "conditional_expression", ")"],
	conditional_expression: ["string", "if", "attribute", "else", "call"],
	subscript: [
		"attribute",
		"[",
		"identifier",
		"]",
		"string",
		"subscript",
		"call",
		"integer",
		"slice",
	],
	as_pattern: ["identifier", "as", "as_pattern_target", "call"],
	with_item: ["as_pattern"],
	pair: [
		"string",
		":",
		"identifier",
		"dictionary",
		"attribute",
		"list_comprehension",
		"call",
	],
	elif_clause: ["elif", "comparison_operator", ":", "block", "call"],
	as_pattern_target: ["identifier"],
	list_splat: ["*", "identifier"],
	dictionary_splat: ["**", "identifier"],
	keyword_argument: ["identifier", "=", "tuple", "true"],
	continue_statement: ["continue"],
	tuple: ["(", "identifier", ",", ")"],
	break_statement: ["break"],
	list_comprehension: ["[", "attribute", "for_in_clause", "]", "subscript"],
	raise_statement: ["raise", "call"],
	for_in_clause: ["for", "identifier", "in", "attribute", "subscript"],
	generator_expression: ["(", "identifier", "for_in_clause", "if_clause", ")"],
	slice: ["integer", ":"],
	if_clause: ["if", "comparison_operator"],
} as const;
